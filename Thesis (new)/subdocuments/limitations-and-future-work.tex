\section{Limitations and Future Work}

\subsection{Refining hydrodynamical realism}

During the thesis-writing phase, we were informed that the formula we used for calculating local water pressure holds only under hydrostatic conditions.
In a dynamic fluid environment, a more complex equation should be used to derive the formula for water pressure \cite{national2003fundamentals}.

For common real time usage like video games, using the simple but inaccurate formula as presented in this article would be just fine; but for serious use cases, the downstream developer should definitely consider switching to the more accurate formula.

\subsection{Generic extension}

Our method isn't bounded to buoyancy simulation---it can as well process other kinds of physical effects of rigid bodies moving through a field.
Some motions, e.g. the electromagnetic force of a charged body moving through a electromagnetic field, affect not only the surface of the body, but also the interior volumes.
By changing the sampling range to be the entirety of the body's volume, our method could be extended to support all motions of this nature.

In real game engines, the traits of an object that exists in the game world is usually governed in a component-wise manner.
In order to realize our method in game engines, one possible way of implementation is to extract an abstract base component that defines a list of interfaces required by the method, and it would perform the internal works automatically as long as downstream developers provide implementation of these interfaces.
The pseudo code for this base class is given in table \ref{table:basefield-definition}.

\begin{table}[H]
	\begin{lstlisting}[style=sharpc]
		abstract class BaseField {
			/* Keeping track of bodies */
		public:
			void TrackBody(Body body);
			void UntrackBody(Body body);
			Body[] trackedBodies { get; }

			/* Sampling */
		private:
			typedef SurfaceSample {
				Point position;
				Vector normal;
			}
			static SurfaceSample[] SampleSurface(Body body, int count);
			static Point[] SampleVolume(Body body, int count);

			/* Physical rules */
		protected:
			bool sampleSurface, sampleVolume;
			typedef Contribution {
				Point position;
				Vector pressure;
				float weight;
			}
			Contribution CalculateSurfaceContribution(SurfaceSample sample);
			Contribution CalculateVolumeContribution(Point position);
		private:
			static void ApplyContributions(Body body, deltaTime, Contribution[] list);

			/* The main functions */
		private:
			void UpdateBody(Body body, float deltaTime) {
				if sampleSurface {
					let samples := SampleSurface(body);
					let contributions := samples.map(CalculateSurfaceContribution);
					ApplyContributions(body, deltaTime, contributions);
				}
				if sampleVolume {
					let positions := SampleVolume(body);
					let contributions := positions.map(CalculateVolumeContribution);
					ApplyContributions(body, deltaTime, contributions);
				}
			}
		public:
			void StepTime(float deltaTime) {
				for each body in trackedBodies
					UpdateBody(body, deltaTime);
			}
		}
	\end{lstlisting}
	\caption{
		The class definition of an abstract field.
		The implementation of some private members are omitted for simplicity.
	}
	\label{table:basefield-definition}
\end{table}

\subsection{Parallel optimization}

The physical contributions of each sample point are totally irrelevant to each other, making parallelization a major potential optimization.
By optimizing on the performance side, increasing the sample amount to a high value wouldn't be a bottleneck anymore, allowing us to achieve a stabler result by the nature of the Monte-Carlo method.
Limited by the time range of the project behind this article, we didn't have the chance to make it to the best.
We'll be thankful to any future researchers continuing on this idea.