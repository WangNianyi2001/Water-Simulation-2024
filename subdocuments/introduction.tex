\section{Introduction}

\subsection{The Difficulties}

The physical interaction between solid and fluid matter has been heavily studied since the very early stage in the field of computer graphics.
Such interaction is called \emph{solid-fluid coupling}.
For a long perdiod of time, it has been studied as a target of offline algorithms.
For a clip of result to be rendered, it would require a rather long time for the algorithm to process the original data of the physical settings.
Only up to the recent decade, realtime methods start to appear to meet the demand in interactive applications like video games\citationNeeded.
As far as we know, it is not easy to simulate this coupling due to the nature of fluid simulation;
it is even harder to accomplish in realtime.

To help explain the complexity, let's take an example:
Assume that a piece of wood plank is falling into water at an angle (figure \ref{stages-of-a-plank-falling-into-water}):
When a side of it first touches the water, that side would immediately get pushed up, resulting in a torque causing the plank to pitch;
then the whole face of the plank will splat itself onto the water surface;
in the last, the plank's momentum is sufficiently decreased and it will slowly sink into or hold still on the water.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1.3in]{figures/stages-of-a-plank-falling-into-water/1.png}
		\includegraphics[width=1.3in]{figures/stages-of-a-plank-falling-into-water/2.png}
		\includegraphics[width=1.3in]{figures/stages-of-a-plank-falling-into-water/3.png}
	\end{center}
	\caption{
		Stages of a plank falling into water.
		Black arrow indicates the net force applied on the plank.
	}
	\label{stages-of-a-plank-falling-into-water}
\end{figure}

To simulate this whole process with a computer, there are two difficulties to be dealt with:

\begin{itemize}
	\item
		First, to get the accurate buoyancy force, one would have to find which parts exactly are sunk in the water and keep making queries to the geometrical shape of the solid object.
		Unfortunately, common game engines only provides very limited interfaces on geometry information of physical bodies.
		As a workaround manually iterate through all the surfaces of the physical body's collision mesh, calculate each forces applied on the surfaces, and sum them up.
		This would be a linear performance cost relating to the amount of triangle surfaces of the floating object.
		The more complex the object's geometry is, the longer the algorithm needs to run.

	\item
		Secondly, finding only the accurate geometry information isn't enough, as every surfaces could be partially sunk in the water.
		If the algorithm only uses the full area of the surfaces to calculate the buoyancy force, then soon as an object touches the water, it would receive the maximum buoyancy force, which leads to artifacts.
		To avoid this, all surfaces of the mesh must clipped in each time the algoritm runs.
		Not only this would cause more performance cost, it also requires a clear, definite boundary of the water surface to be queried during runtime.
		As the implementation of the water body varies, this might even be impossible to achieve.
\end{itemize}

In order to overcome the above difficulties, in this article a Monte-Carlo based method is proposed to achieve a convincing buoyancy simulation in realtime.

\subsection{Related Works}
Before the year of 2000, principles and methods of realtime water simulation did have been proposed by researchers\cite{CHE97}, but only theoretically.
Although many of the researches are labelled as ``realtime'' or ``interactive'', due to the limitation of the hardware performance of the time, these researches could only be used to simulate fluid bodies in a small volume of a virtual space.

Only in the later half of the 2000 decade, researches on true interactive fluid simulation started appearing.
An earliest example could be a study in 2008\cite{JUD08}, where an algorithm of simulating the motion of large water bodies on a open terrain is proposed.
However, researches of this period are still not suitable for our problem:
Either that they only cares the water's behavior on a large, terrain-level scale;
or that they are too focused on simulating the detailed local behavior of the water body.
With these methods, we cannot smoothly transition the local and large-scale water behavior without costing extra performance.

In 2020, an algorithm for simulating sinking solids was proposed\cite{RBM20}.
It can simulate the buoyancing behavior in realtime, however though, there are some limitations of their methods:
\begin{enumerate}
	\item It uses baked proxy volumes to store and calculate ``how waterlogged'' each section of a solid object are.

		Using a proxy mesh could cause potential problems.
		For example, the visual appearance of the object could change in runtime.
		If the proxy mesh doesn't change along, artifacts may be induced;
		but if the developer does remember to synchronize them, then baking would be performed in runtime, which leads to performance issue.
		Also, this proxy-based calculation is itself a simplification of the underlying physical effect.
		It may be able to produce an okay result for normal meshes, but on overly-simple or too-complex meshes, it might look off.

	\item It modifies the velocities of the solid objects' directly.

		Modifying physical properties directly is usually avoided in physical simulations, as there might be many other effects that are happening at the same time.
		If one of them directly modifies the target property, it is practically messing with all the other effects by ignoring and overwriting their contributions.
		Normally, developers would like algorithms to add their physical contributions onto the bodies.

\end{enumerate}
Other methods, as discussed in the above article, are either not suitable for interactive applications or not physically accurate.

\fbox{\begin{minipage}{\textwidth}todo\end{minipage}}